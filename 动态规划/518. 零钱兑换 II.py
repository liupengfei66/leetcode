# https://leetcode.cn/problems/coin-change-ii/
# 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。
# 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。
# 假设每一种面额的硬币有无限个。 

# 完全背包的背包就是从小到大遍历，想不明白，可以按第一个例子手动画一下就明白了
# 这题跟494是一个性质的，属于背包装满问题
# 此外还有一个重点是，这里是求的凑成的方案个数，是不用考虑顺序的，即凑成5块钱，{1,4}和{4,1}都是一种方案，属于组合数，
# 所以就必须先遍历物品，再遍历背包，因为物品按顺序遍历，那么永远不会出现先加入4，再加入1的情况，一定是先加入了1，再加入了4。
# 而如果是{1,4}和{4,1}算两种方案，那么就要先遍历背包，再遍历物品了，此时因为是先考虑背包，
# 那么在考虑dp[5]时，你会先遍历1，此时是dp[5]+=dp[4]，也就先考虑了4，再考虑了1，然后你会继续遍历到4，
# 此时dp[5]+=d[1]，这时就是先考虑了1，再考虑了4，所以就重复计算了。

from typing import List
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        # dp[j] - 凑成j的组合数为dp[j]，初始化dp[0]=1，为了递推公式，可以理解为凑成0块钱有1种方案，就是不取
        dp = [1] + [0] * amount
        for i in range(len(coins)):
            for j in range(coins[i], amount+1):
                dp[j] += dp[j-coins[i]]

        return dp[amount]